// 2025-06-22
class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    unordered_set<int> initialSet(initial.begin(), initial.end());
    int knownMin = 300;
    int result = -1;
    vector<bool> visited(graph.size(), false);
    for (int i : initial) {
      initialSet.erase(i);
      // cout << "i = " << i << endl;
      int temp = bfs(graph, initialSet, visited, knownMin);
      // cout << "i = " << i << ", temp = " << temp << endl;
      if (temp < knownMin) {
        knownMin = temp;
        result = i;
      } else if (temp == knownMin) {
        result = min(result, i);
      }
      initialSet.insert(i);
    }
    return result;
  }

 private:
  int bfs(
      const vector<vector<int>>& graph,
      const unordered_set<int>& initial,
      vector<bool>& visited,
      int knownMin) {
    int n = graph.size();
    fill(visited.begin(), visited.end(), false);
    // for (bool v :visited) {
    //   cout << v << " ";
    // }
    // cout << endl;
    queue<int> q;
    for (int i : initial) {
      visited[i] = true;
      q.push(i);
    }
    int result = 0;
    while (!q.empty()) {
      int i = q.front();
      // cout << "deque: " << i << endl;
      q.pop();
      for (int j = 0; j < n; ++j) {
        if (graph[i][j] && !visited[j]) {
          ++result;
          visited[j] = true;
          q.push(j);
        }
      }
    }
    return result;
  }
};
