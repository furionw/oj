// 2025-06-22
// Method 2: Union-Find
class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();

    vector<int> parents(n, -1);
    vector<int> ranks(n, 1);

    for (int i = 0; i < n; ++i) {
      parents[i] = i;
    }

    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        if (i != j && graph[i][j]) {
          unionFind(parents, ranks, i, j);
        }
      }
    }

    unordered_map<int, vector<int>> networks;
    for (int i : initial) {
      networks[find(parents, i)].push_back(i);
    }

    int result = n + 1;
    int knownMax = 0;
    for (auto [p, vertices] : networks) {
      if (vertices.size() > 1) {
        int i = *min_element(vertices.begin(), vertices.end());
        if (knownMax == 0) {
          result = min(result, i);
        }
        continue;
      }
      int i = vertices.front();
      int r = rank(parents, ranks, i);
      if (r > knownMax) {
        knownMax = r;
        result = i;
      } else if (r == knownMax) {
        result = min(result, i);
      }
    }
    return result;
  }

 private:
  int rank(
      vector<int>& parents,
      vector<int>& ranks,
      int v) {
    return ranks[find(parents, v)];
  }

  void unionFind(
      vector<int>& parents,
      vector<int>& ranks,
      int u, int v) {
    int pu = find(parents, u);
    int pv = find(parents, v);
    if (pu != pv) {
      parents[pv] = pu;
      ranks[pu] += ranks[pv];
    }
  }

  int find(vector<int>& parents, int v) {
    return parents[v] == v
        ? v
        : parents[v] = find(parents, parents[v]);
  }
};

// Method 1: BFS
class Solution {
 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    unordered_set<int> initialSet(initial.begin(), initial.end());
    int knownMin = 300;
    int result = -1;
    vector<bool> visited(graph.size(), false);
    for (int i : initial) {
      initialSet.erase(i);
      int temp = bfs(graph, initialSet, visited, knownMin);
      if (temp < knownMin) {
        knownMin = temp;
        result = i;
      } else if (temp == knownMin) {
        result = min(result, i);
      }
      initialSet.insert(i);
    }
    return result;
  }

 private:
  int bfs(
      const vector<vector<int>>& graph,
      const unordered_set<int>& initial,
      vector<bool>& visited,
      int knownMin) {
    int n = graph.size();
    fill(visited.begin(), visited.end(), false);
    queue<int> q;
    for (int i : initial) {
      visited[i] = true;
      q.push(i);
    }
    int result = 0;
    while (!q.empty()) {
      int i = q.front();
      q.pop();
      for (int j = 0; j < n; ++j) {
        if (graph[i][j] && !visited[j]) {
          ++result;
          if (result > knownMin) {
            return result;
          }
          visited[j] = true;
          q.push(j);
        }
      }
    }
    return result;
  }
};
